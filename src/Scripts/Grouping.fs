module Scripts.Grouping

open Npgsql

open SL.AnswerMonad
open SL.Geo.Coord
open SL.Geo.WellKnownText
open SL.PGSQLConn
open SL.CsvOutput
open SL.ScriptMonad
open SL.PostGIS

// Note Fsharp's groupBy is not the same as Haskell's groupBy.
// Haskell's groupBy does not do a global "collect" instead it is a linear scan,
// initializing a new group when a transition occurs.
// For "Mississippi" this means we have multiple groups of "i" and "s" in Haskell.
//
// Haskell> groupBy (==) "Mississippi"
// ["M","i","ss","i","ss","i","pp","i"]
//
// F#> Seq.groupBy id "Mississippi" ;;
//  seq
//    [('M', seq ['M']); ('i', seq ['i'; 'i'; 'i'; 'i']);
//     ('s', seq ['s'; 's'; 's'; 's']); ('p', seq ['p'; 'p'])]
//
// FSharpxCollections provides List.groupNeighboursBy which has 
// the same behaviour as Haskell, but a slightly different 
// signature.


/// This is just a record for the return type of groupBy rather than a pair.
type Grouping<'Key,'a> = 
    { GroupingKey: 'Key
      Elements: seq<'a> }

      
// Design note
// The concept of groupBy is so "small" that we don't need to 
// put it into a dictionary. (At the moment...)

let groupingBy (projection:'T -> 'Key) (source:seq<'T>) : seq<Grouping<'Key,'T>> = 
    Seq.map (fun (a,b) -> {GroupingKey = a; Elements = b}) <| Seq.groupBy projection source

/// Ideally the Key should match a single item if it matches 
/// multiple ones the sort order is unspecified.
let sortToKeyList (projection:'T -> 'Key) (source:seq<'T>) (keyList:'Key list) : seq<'T> = 
    let rec work ac keys src = 
        match src with
        | [] -> List.rev ac
        | xs -> 
            match keys with
            | [] -> 
                let front = List.rev ac in front @ xs
            | k1 :: ks -> 
                let (hits,misses) = List.partition (fun x -> k1 = projection x) xs
                work (hits @ ac) ks misses
    List.toSeq <| work [] keyList (Seq.toList source)




// ***** Concave and convex hulls

/// MakeCsvRow - the int parameter is a incrementing serial 
/// number, users can ignore it if they wish.
/// TODO - this dictionary is too big, we should have one 
/// dictionary for grouping and other dictionaries for 
/// generating output.
type GroupingMakeHullsDict<'Key,'a> = 
    { GroupByOperation: 'a -> 'Key
      GetElementLoc: 'a -> WGS84Point option
      CsvHeaders: string list
      MakeCsvRow: int -> 'Key -> WellKnownText<WGS84> -> seq<'a> -> RowWriter
    }

let private extractPoints (dict:GroupingMakeHullsDict<'Key,'a>) (source:Grouping<'Key,'a>) : seq<WGS84Point> = 
    Seq.choose id <| Seq.map (dict.GetElementLoc) source.Elements

let private concaveHull1 (dict:GroupingMakeHullsDict<'Key,'a>) (source:Grouping<'Key,'a>) (targetPercent:float) : Script<WellKnownText<WGS84>> = 
    pgConcaveHull (Seq.toList <| extractPoints dict source) targetPercent

let private convexHull1 (dict:GroupingMakeHullsDict<'Key,'a>) (source:Grouping<'Key,'a>) : Script<WellKnownText<WGS84>> = 
    pgConvexHull (Seq.toList <| extractPoints dict source)

let private centroid1 (dict:GroupingMakeHullsDict<'Key,'a>) (source:Grouping<'Key,'a>) : Script<WGS84Point option> = 
    pgCentroid wktIsoWGS84 (Seq.toList <| extractPoints dict source)


/// THE WKT generated by PostGIS for hulls can contain different geometries 
/// (POINT, LINESTRING, POLYGON) depending on on the number of points in the
/// result set.
/// QGIS Delimited Text Layer Import issues warnings (soift errors) if the import
/// has multiple geometry types.
let private filterPOLYGONs (source:seq<'Key * WellKnownText<'srid> * seq<'a>>) : seq<'Key * WellKnownText<'srid> * seq<'a>> = 
    Seq.filter (fun (a,WellKnownText(b),c) -> b.Contains "POLYGON") source

type ConcaveHullOptions = 
    { TargetPercentage: float }



let private genHullsCsv (make1:Grouping<'Key,'a> -> Script<'Key * WellKnownText<WGS84> * seq<'a>>) (dict:GroupingMakeHullsDict<'Key,'a>) (source:seq<'a>) (outputFile:string) : Script<unit> =
    scriptMonad { 
        let groups = groupingBy dict.GroupByOperation source
        let! hulls = traverseM make1 groups
        let rows = 
            Seq.mapi (fun ix (key,wkt,elts) -> dict.MakeCsvRow ix key wkt elts) <| filterPOLYGONs hulls
        let csvProc:CsvOutput<unit> = writeRowsWithHeaders dict.CsvHeaders rows
        do! liftAction <| outputToNew {Separator=","} csvProc outputFile
        }



// Note - This API is making Hulls (plural) as it was our original use case.
// Making a single hull is done by functions in Scripts.PostGIS.
// Maybe splitting between two modules is a bad API decision.

let generateConcaveHullsCsv (options:ConcaveHullOptions) (dict:GroupingMakeHullsDict<'Key,'a>) (source:seq<'a>) (outputFile:string) : Script<unit> =
    let make1 (group1:Grouping<'Key,'a>) : Script<'Key * WellKnownText<WGS84> * seq<'a>> = 
        fmapM (fun x -> (group1.GroupingKey, x, group1.Elements)) 
            <| concaveHull1 dict group1 options.TargetPercentage
    genHullsCsv make1 dict source outputFile

let generateConvexHullsCsv (dict:GroupingMakeHullsDict<'Key,'a>) (source:seq<'a>) (outputFile:string) : Script<unit> =
    let make1 (group1:Grouping<'Key,'a>) : Script<'Key * WellKnownText<WGS84> * seq<'a>> =  
        fmapM (fun x -> (group1.GroupingKey, x, group1.Elements)) 
            <| convexHull1 dict group1
    genHullsCsv make1 dict source outputFile


// ***** Centroid

/// TODO - return WktMultiPoint or (WGS84Point list)?
let generateCentroids (dict:GroupingMakeHullsDict<'Key,'a>) (source:seq<'a>) : Script<WGS84Point list> =
    scriptMonad {
        return []
        }