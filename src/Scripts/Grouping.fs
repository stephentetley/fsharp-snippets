module Scripts.Grouping

open Npgsql

open SL.AnswerMonad
open SL.Geo.Coord
open SL.PGSQLConn
open SL.CsvOutput
open SL.ScriptMonad

open Scripts.PostGIS

// Note Fsharp's groupBy is not the same as Haskell's groupBy.
// Haskell's groupBy does not do a global "collect" instead it is a linear scan,
// initializing a new group when a transition occurs.
// For "Mississippi" this means wwe have multiple groups of "i" and "s".


/// This is just a record for the return type of groupBy rather than a pair.
type Grouping<'Key,'a> = 
    { GroupingKey: 'Key
      Elements: seq<'a> }

let groupingBy (projection:'a -> 'Key) (source:seq<'a>) : seq<Grouping<'Key,'a>> = 
    Seq.map (fun (a,b) -> {GroupingKey = a; Elements = b}) <| Seq.groupBy projection source


/// This is just temporary at some point use datatypes from the SL.WellKnownText module
type WKText = string 


// ***** Concave and convex hulls

// MakeCsvRow - the int parameter is a incrementing serial number, users can ignore it
// if the wish.
type GroupingMakeHullsDict<'Key,'a> = 
    { GroupByOperation: 'a -> 'Key
      GetElementLoc: 'a -> WGS84Point option
      CsvHeaders: string list
      MakeCsvRow: int -> 'Key -> WKText -> seq<'a> -> RowWriter
    }

let private extractPoints (dict:GroupingMakeHullsDict<'Key,'a>) (source:Grouping<'Key,'a>) : seq<WGS84Point> = 
    Seq.choose id <| Seq.map (dict.GetElementLoc) source.Elements

let private concaveHull1 (dict:GroupingMakeHullsDict<'Key,'a>) (source:Grouping<'Key,'a>) (targetPercent:float) : Script<string> = 
    pgConcaveHull (Seq.toList <| extractPoints dict source) targetPercent

let private convexHull1 (dict:GroupingMakeHullsDict<'Key,'a>) (source:Grouping<'Key,'a>) : Script<string> = 
    pgConvexHull (Seq.toList <| extractPoints dict source)


/// THE WKT generated by PostGIS for hulls can contain different geometries 
/// (POINT, LINESTRING, POLYGON) depending on on the number of points in the
/// result set.
/// QGIS Delimited Text Layer Import issues warnings (soift errors) if the import
/// has multiple geometry types.
let private filterPOLYGONs (source:seq<'Key * WKText * seq<'a>>) : seq<'Key * WKText * seq<'a>> = 
    Seq.filter (fun (a,b,c) -> b.Contains "POLYGON") source

type ConcaveHullOptions = 
    { TargetPercentage: float }



let private genHullsCsv (make1:Grouping<'Key,'a> -> Script<'Key * WKText * seq<'a>>) (dict:GroupingMakeHullsDict<'Key,'a>) (source:seq<'a>) (outputFile:string) : Script<unit> =
    scriptMonad { 
        let groups = groupingBy dict.GroupByOperation source
        let! hulls = traverseM make1 groups
        let rows = 
            Seq.mapi (fun ix (key,wkt,elts) -> dict.MakeCsvRow ix key wkt elts) <| filterPOLYGONs hulls
        let csvProc:CsvOutput<unit> = writeRowsWithHeaders dict.CsvHeaders rows
        do! liftAction <| outputToNew {Separator=","} csvProc outputFile
        }

// Note - This API is making Hulls (plural) as it was our original use case.
// Making a single hull is done by functions in Scripts.PostGIS.
// Maybe splitting between two modules is a bad API decision.

let generateConcaveHullsCsv (options:ConcaveHullOptions) (dict:GroupingMakeHullsDict<'Key,'a>) (source:seq<'a>) (outputFile:string) : Script<unit> =
    let make1 (group1:Grouping<'Key,'a>) : Script<'Key * WKText * seq<'a>> = 
        fmapM (fun x -> (group1.GroupingKey, x, group1.Elements)) 
            <| concaveHull1 dict group1 options.TargetPercentage
    genHullsCsv make1 dict source outputFile

let generateConvexHullsCsv (dict:GroupingMakeHullsDict<'Key,'a>) (source:seq<'a>) (outputFile:string) : Script<unit> =
    let make1 (group1:Grouping<'Key,'a>) : Script<'Key * WKText * seq<'a>> =  
        fmapM (fun x -> (group1.GroupingKey, x, group1.Elements)) 
            <| convexHull1 dict group1
    genHullsCsv make1 dict source outputFile


// ***** Centroid

